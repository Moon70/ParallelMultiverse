package abyss.parallelmultiverse.part08ribbons;

import abyss.lunarengine.gfx.LordFader;
import abyss.lunarengine.gfx.PolarBear;
import abyss.lunarengine.gfx.Tools2D;
import abyss.lunarengine.sinatra.Sinatra;

public class Ribbon {
	public static Tools2D tools2d;
	
	private static final int SHIFT=12;
	
	private Sinatra sinusRibbonY2;

	private int offsetX;
	public int offsetY;
	private double angle;
	private static final int RADIUS=250;

	private LordFader fader1;
	private LordFader fader2;
	private double alphaDelta;
	private int deltaSinus;
	public int deltaY;
	public boolean enabled;
	public static boolean fadeout;
	public static Sinatra sinatra=Sinatra.getInstance(new double[]{720.0,1.0,25.0,0.5,0.0,360.0});//generated by LunarTools Sinus Editor 1.0
	private int rendermethod=1;
	public static boolean switchToDottyMode;
	
 	public Ribbon(int offsetX,int offsetY,double angle, LordFader fader1, LordFader fader2, double alphaDelta, int deltaSinus,int deltaY) {
		this.offsetX=offsetX;
		this.offsetY=offsetY;
		this.angle=angle;
		this.fader1=fader1;
		this.fader2=fader2;
		this.alphaDelta=alphaDelta;
		this.deltaSinus=deltaSinus;
		this.deltaY=deltaY;
		this.enabled=true;
		
		sinusRibbonY2=sinatra.clone();
		sinusRibbonY2.move(50);
	}
	
	public void vbi() {
		sinusRibbonY2.move(deltaSinus);
		angle+=alphaDelta;
		if((offsetY+=deltaY)>1200) {
			if(fadeout) {
				enabled=false;
			}else {
				offsetY-=1600;
				if(switchToDottyMode) {
					rendermethod=2;
				}
			}
		}
	}
	
	public void render() {
		if(!enabled) {
			return;
		}
		sinusRibbonY2.beginRender();
		sinusRibbonY2.getNextValue(150);

		int x1=PolarBear.calcXint(-RADIUS>>1, angle);
		int y1=PolarBear.calcYint(-RADIUS>>1, angle);
		int x2=PolarBear.calcXint(RADIUS>>1, angle);
		int y2=PolarBear.calcYint(RADIUS>>1, angle);

		int dx=((x2-x1)<<SHIFT)/RADIUS;
		int dy=((y2-y1)<<SHIFT)/RADIUS;
		int px=-dx*(RADIUS>>1);
		int py=-dy*(RADIUS>>1);
		int delta;
		final double alpha=(angle+90)*PolarBear.DEG2RAD;
		int deltaY;
		int index;
		if(rendermethod==1) {
			for(int i=0;i<RADIUS;i++) {
				deltaY=sinusRibbonY2.getNextDeltaValue(1);
				index=deltaY*RADIUS/25;
				if(deltaY>0) {
					tools2d.pixel=fader1.colors[index];
				}else {
					tools2d.pixel=fader2.colors[-index];
				}
				delta=(int)(Math.cos(alpha)*deltaY);
				x1=((px+((1<<SHIFT)>>1))>>SHIFT);
				x2=x1+delta;
				x1-=delta;

				delta=(int)(Math.sin(alpha)*deltaY);
				y1=((py+((1<<SHIFT)>>1))>>SHIFT);
				y2=y1+delta;
				y1-=delta;

				if(x1==x2 && y1==y2) {
					x2++;
				}
				tools2d.lineClipBold(x1+offsetX, y1+offsetY, x2+offsetX, y2+offsetY);
				px+=dx;
				py+=dy;
			}
		}else {
			dx+=dx+dx;
			dy+=dy+dy;
			for(int i=0;i<RADIUS;i+=3) {
				deltaY=sinusRibbonY2.getNextDeltaValue(3);
				index=deltaY*RADIUS/25;
				if(deltaY>0) {
					tools2d.pixel=fader1.colors[index];
				}else {
					tools2d.pixel=fader2.colors[-index];
				}
				delta=(int)(Math.cos(alpha)*deltaY);
				x1=((px+((1<<SHIFT)>>1))>>SHIFT);
				x2=x1+delta;
				x1-=delta;

				delta=(int)(Math.sin(alpha)*deltaY);
				y1=((py+((1<<SHIFT)>>1))>>SHIFT);
				y2=y1+delta;
				y1-=delta;

				if(x1==x2 && y1==y2) {
					x2++;
				}
				tools2d.dottyLine(x1+offsetX, y1+offsetY, x2+offsetX, y2+offsetY);
				px+=dx;
				py+=dy;
			}
		}
	}
	
}
