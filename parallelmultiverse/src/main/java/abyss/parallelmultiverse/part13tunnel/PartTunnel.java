package abyss.parallelmultiverse.part13tunnel;

import java.util.Vector;

import abyss.lunarengine.APart;
import abyss.lunarengine.LunarEngine;
import abyss.lunarengine.Screen;
import abyss.lunarengine.gfx.LordFader;
import abyss.lunarengine.gfx.PolarBear;
import abyss.lunarengine.gfx.Tools2D;
import abyss.lunarengine.sinatra.Sinatra;
import abyss.parallelmultiverse.part11bobscubes.PartBobCubes;

public class PartTunnel extends APart{
	public static final int BACKGROUNDCOLOR = 0x000020;

	private static final int SHIFT=12;
	public double lightningLinecountDelta;
	public double lightningLinecountDest;
	public double lightningRndDelta;
	public double lightningRndDest;
	public boolean enableRadiusDelta;
	public boolean enableAngleDelta;
	
	private double lightningLinecount;
	private double lightningRnd;
	private int newRingIndex;
	private int newRingDelayCount;
	private volatile int masterX;
	private volatile int masterY;
	private int masterXDelta;
	private int masterYDelta;
	
	private Sinatra sinatraX;
	private Sinatra sinatraY;
	private Sinatra sinatraR;
	private Sinatra sinatraA;
	private Vector<Ring> rings;
	private LordFader faderBackground;
	
	private static final int TUNNEL_RINGCOUNT=48+16;
	private static final int TUNNEL_ANGLESTEP=12;
	private static final int TUNNEL_POINTCOUNT=360/TUNNEL_ANGLESTEP;
	private static final int TUNNEL_NEWRINGDELAY=5;
	private static final int TABLESIZE=TUNNEL_RINGCOUNT*TUNNEL_NEWRINGDELAY;
	
	private Tools2D tools2D;
	private int[] radTable;
	private int[] colTable;

	public static void main(String[] args){
		try{
			LunarEngine.initializeEngine();
			APart partTunnel=new PartTunnel();
			partTunnel.precalc();
			partTunnel.initialize();
			LunarEngine.setActivePart(partTunnel);
			LunarEngine.startEngine();
		}catch(Throwable throwable){
			LunarEngine.throwableHandler(throwable);
		}
	}
	
	public PartTunnel() {
		radTable=new int[TABLESIZE];
		colTable=new int[TABLESIZE+3];
	}
	
	@Override
	public void precalc(){
		faderBackground=new LordFader(PartBobCubes.BACKGROUNDCOLOR,BACKGROUNDCOLOR,240);
		tools2D=new Tools2D();
		sinatraX=Sinatra.getInstance(new double[]{2048.0,3.0,1.0,0.703125,0.0,360.0,460.0,0.17578125,0.0,360.0,250.0,0.3515625,0.0,360.0,0.0,0.0,0.0});//generated by LunarTools Sinus Editor 1.0
		sinatraY=Sinatra.getInstance(new double[]{2048.0,2.0,1.0,0.703125,0.0,360.0,260.0,0.17578125,0.0,360.0,250.0,0.3515625,0.0,360.0,0.0,0.0,0.0});//generated by LunarTools Sinus Editor 1.0
		sinatraR=Sinatra.getInstance(new double[]{3600.0,3.0,40.0,0.3,0.0,360.0,50.0,0.5,0.0,360.0,10.0,2.0,0.0,360.0});//generated by LunarTools Sinus Editor 1.0
		sinatraA=Sinatra.getInstance(new double[]{185040.0,3.0,180.0,0.5,0.0,360.0,90.0,0.7,0.0,360.0,83.0,1.0,0.0,360.0});//generated by LunarTools Sinus Editor 1.0;

		for(int i=0;i<TABLESIZE;i++) {
			radTable[i]=(int)(20.0+850.0/((double)(TABLESIZE-i)/20.0));
			//colTable[i]=(int)(255.0*i/values);
			colTable[i]=(int)(256.0*i/TABLESIZE);//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
			colTable[i]=colTable[i]+(colTable[i]<<8)+(colTable[i]<<16);
		}
	}
	
	@Override
	public void initialize() {
		rings=new Vector<Ring>();
		for(int i=0;i<TUNNEL_RINGCOUNT;i++) {
			rings.add(new Ring(TUNNEL_POINTCOUNT));
		}
		lightningLinecount=1;
		lightningLinecountDelta=0;
		lightningLinecountDest=lightningLinecount;
		lightningRnd=1;
		lightningRndDelta=0;
		lightningRndDest=lightningRnd;
		enableRadiusDelta=false;
		enableAngleDelta=false;
		newRingIndex=0;
		newRingDelayCount=TUNNEL_NEWRINGDELAY;
		masterX=100 << SHIFT;
		masterY=50 << SHIFT;
		masterXDelta=0;
		masterYDelta=0;
		sinatraX.setIndex(0);
		sinatraY.setIndex(0);
		sinatraR.setIndex(0);
		sinatraA.setIndex(0);
	}
	
	private Ring vbi_currentRing;
	@Override
	public void vbi(){
		for(int t=0;t<TUNNEL_RINGCOUNT;t++) {
			vbi_currentRing=rings.get(t);
			vbi_currentRing.radiusIndex++;
		}

		masterX+=masterXDelta;
		masterY+=masterYDelta;
		if(--newRingDelayCount==0) {
			newRingDelayCount=TUNNEL_NEWRINGDELAY;
			vbi_currentRing=rings.firstElement();
			rings.remove(0);
			rings.add(vbi_currentRing);
			vbi_currentRing.x=0;
			vbi_currentRing.y=0;
			vbi_currentRing.x=sinatraX.getNextValue(22) << SHIFT;
			vbi_currentRing.y=sinatraY.getNextValue(20) << SHIFT;
			vbi_currentRing.radiusIndex=0;
			if(enableRadiusDelta) {
				vbi_currentRing.radiusDelta=sinatraR.getNextValue(30);
			}
			if(enableAngleDelta) {
				vbi_currentRing.angleDelta=sinatraA.getNextValue(3);
			}
			if(newRingIndex+1<TUNNEL_RINGCOUNT) {
				newRingIndex++;
			}else {
				newRingIndex=0;
			}

			vbi_currentRing=rings.firstElement();
			masterXDelta=(-vbi_currentRing.x-masterX)/(TUNNEL_NEWRINGDELAY);
			masterYDelta=(-vbi_currentRing.y-masterY)/(TUNNEL_NEWRINGDELAY);
		}
		
		if(lightningLinecountDelta<0) {
			if((lightningLinecount+=lightningLinecountDelta)<=lightningLinecountDest) {
				lightningLinecountDelta=0;
			}
		}else {
			if((lightningLinecount+=lightningLinecountDelta)>=lightningLinecountDest) {
				lightningLinecountDelta=0;
			}
		}

		if(lightningRndDelta<0) {
			if((lightningRnd+=lightningRndDelta)<=lightningRndDest) {
				lightningRndDelta=0;
			}
		}else {
			if((lightningRnd+=lightningRndDelta)>=lightningRndDest) {
				lightningRndDelta=0;
			}
		}
		faderBackground.fade(1);
	}

	private Ring worker_lastRing;
	private Ring worker_currentRing;

	@Override
	public void worker2(){
		tools2D.screendataWorking=LunarEngine.screendataToWork;
		tools2D.rnd=(int)lightningRnd;
		tools2D.lightningLineParts=(int)lightningLinecount;
		int radius;
		int angle;
		int x=0;
		int y=0;
		int lastX;
		int lastY;
		int firstX;
		int firstY;
		worker_lastRing=null;
		int ringCount;
		for(int ringNumber=TUNNEL_RINGCOUNT-1;ringNumber>=0;ringNumber--) {
			worker_currentRing=rings.get(ringNumber);
			tools2D.pixel=colTable[worker_currentRing.radiusIndex];
			radius=radTable[worker_currentRing.radiusIndex]+worker_currentRing.radiusDelta;
			angle=worker_currentRing.angleDelta;
			lastX=0;
			lastY=0;
			firstX=0;
			firstY=0;
			for(ringCount=0;ringCount<TUNNEL_POINTCOUNT;ringCount++,angle+=TUNNEL_ANGLESTEP) {
				x=PolarBear.calcXint(radius, angle)+Screen.screenCenterX+((worker_currentRing.x +masterX) >> SHIFT);
				y=PolarBear.calcYint(radius, angle)+Screen.screenCenterY+((worker_currentRing.y +masterY) >> SHIFT);
				if(ringCount==0) {
					firstX=x;
					firstY=y;
				}
				if(lastX+lastY>0) {
					tools2D.lightningLine(x, y, lastX, lastY);
				}
				lastX=x;
				lastY=y;
				if(worker_lastRing!=null) {
					tools2D.lightningLine(x, y, worker_lastRing.pointsX[ringCount], worker_lastRing.pointsY[ringCount]);
				}
				worker_currentRing.pointsX[ringCount]=x;
				worker_currentRing.pointsY[ringCount]=y;
			}
			worker_lastRing=worker_currentRing;
			tools2D.lightningLine(x, y, firstX, firstY);
		}
	}

	@Override
	public void worker3(){
		Screen.screenClear(LunarEngine.screendataToReset,faderBackground.getCurrentColor());
	}

	@Override
	public void rotateBuffers() {
		rotateBuffers5();
	}
}
