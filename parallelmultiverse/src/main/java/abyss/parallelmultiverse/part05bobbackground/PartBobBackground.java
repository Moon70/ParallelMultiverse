package abyss.parallelmultiverse.part05bobbackground;

import abyss.lunarengine.APart;
import abyss.lunarengine.LunarEngine;
import abyss.lunarengine.Screen;
import abyss.lunarengine.gfx.Bob;
import abyss.lunarengine.gfx.BobFactory;
import abyss.lunarengine.gfx.LordFader;
import abyss.lunarengine.sinatra.Sinatra;
import abyss.parallelmultiverse.part02abysslogo.PartAbyssLogo;
import abyss.parallelmultiverse.part07turnbars.PartTurnbars;

public class PartBobBackground extends APart{
	private Sinatra[] sinatraX;
	private Sinatra[] sinatraY;
	private int[][] tunnel;
	private static final int TUNNEL_LENGTH=160+1000;
	private int tunnelIndex;
	
	private Bob bob;
	private int sinTab[];
	private int cosTab[];
	
	public int initialRadius=40;
	public int sinStepX=8;
	public int sinStepY=8;
	public int sinusOffset=1;
	public boolean fadeOut;
	
	private LordFader faderBackground;
	public boolean enableBackgroundFader;
	private static final int SHIFT=12;

	
	public static void main(String[] args){
		try{
			LunarEngine.initializeEngine();
			PartBobBackground partBobsBack=new PartBobBackground();
			partBobsBack.precalc();
			LunarEngine.setActivePart(partBobsBack);
			LunarEngine.startEngine();
		}catch(Throwable throwable){
			LunarEngine.throwableHandler(throwable);
		}
	}

	public PartBobBackground() {
		sinTab=new int[360];
		cosTab=new int[360];
		tunnel=new int[TUNNEL_LENGTH][4];
	}
	
	@Override
	public void precalc(){
		faderBackground=new LordFader(PartAbyssLogo.BACKGROUNDCOLOR,PartTurnbars.BACKGROUNDCOLOR,90);
		
		for(int i=0;i<360;i++) {
			sinTab[i]=(int)(Math.sin(i*Math.PI/180)*(1<<SHIFT)+0.5);
			cosTab[i]=(int)(Math.cos(i*Math.PI/180)*(1<<SHIFT)+0.5);
		}
		
		bob=BobFactory.createBob(PartBobBackground.class, "/data/ball32/");
		bob.enabled=true;
		int p=0;
		for(int i=0;i<bob.bobdata[0].length;i++) {
			p=bob.bobdata[0][i];
			if(p<0) {
				bob.bobdata[0][i]=((bob.bobdata[0][i] & 0xfefefe)>>1) | 0xff000000;
			}
		}
		
		sinatraX=new Sinatra[3];
		sinatraY=new Sinatra[3];
		
		sinatraX[0]=Sinatra.getInstance(new double[]{7200.0,5.0,100.0,0.05,0.0,360.0,80.0,0.2,0.0,360.0,72.0,0.4,0.0,360.0,116.0,0.2,0.0,360.0,199.0,0.5,0.0,180.0});//generated by LunarTools Sinus Editor 1.0
		sinatraY[0]=Sinatra.getInstance(new double[]{7200.0,4.0,130.0,0.05,0.0,360.0,103.0,0.3,0.0,360.0,130.0,1.0,0.0,180.0,68.0,2.0,0.0,360.0});//generated by LunarTools Sinus Editor 1.0

		sinatraX[1]=Sinatra.getInstance(new double[]{7200.0,3.0,100.0,0.3,0.0,360.0,199.0,0.25,0.0,360.0,156.0,0.9,0.0,360.0});//generated by LunarTools Sinus Editor 1.0
		sinatraY[1]=Sinatra.getInstance(new double[]{7200.0,3.0,190.0,0.25,0.0,360.0,132.0,0.2,0.0,360.0,78.0,1.5,0.0,360.0});//generated by LunarTools Sinus Editor 1.0
	
		sinatraX[2]=Sinatra.getInstance(new double[]{3600.0,5.0,400.0,0.2,180.0,360.0,168.0,1.5,0.0,360.0,83.0,0.1,0.0,360.0,116.0,0.2,0.0,360.0,400.0,1.0,0.0,180.0});//generated by LunarTools Sinus Editor 1.0
		sinatraY[2]=Sinatra.getInstance(new double[]{3600.0,4.0,164.0,0.05,180.0,360.0,193.0,0.3,0.0,360.0,300.0,1.0,0.0,180.0,189.0,1.5,0.0,360.0});//generated by LunarTools Sinus Editor 1.0

		for(int i=0;i<TUNNEL_LENGTH;i++) {
			tunnel[i][0]=0;
			tunnel[i][1]=0;
			tunnel[i][2]=initialRadius;
			tunnel[i][3]=-1;
		}
	}

	@Override
	public void vbi(){
		tunnel[tunnelIndex][0]=sinatraX[sinusOffset].getNextValue(sinStepX);
		tunnel[tunnelIndex][1]=sinatraY[sinusOffset].getNextValue(sinStepY);
		tunnel[tunnelIndex][2]=initialRadius;
		if(fadeOut) {
			tunnel[tunnelIndex][3]=-1;
			if(++tunnelIndex==TUNNEL_LENGTH) {
				tunnelIndex=0;
			}
			tunnel[tunnelIndex][3]=-1;
		}else {
			tunnel[tunnelIndex][3]=0;
		}
		if(++tunnelIndex==TUNNEL_LENGTH) {
			tunnelIndex=0;
		}
		
		if(enableBackgroundFader) {
			faderBackground.fade(1);
		}
	}

	@Override
	public void worker2(){
		Bob.screendataToWork=LunarEngine.screendataToWork2;
		int render_r;
		int deltaAngle=0;
		for(int t=0;t<TUNNEL_LENGTH;t++) {
			tunnel[t][2]+=2;
			if(tunnel[t][3]>=0) {
				render_r=tunnel[t][2];
				for(int i=0;i<4;i++) {
					bob.render(
							calcXint(render_r, i*-20+ ++deltaAngle)+Screen.screenCenterX+tunnel[t][0], 
							calcYint(render_r, i*40+ deltaAngle)+Screen.screenCenterY+tunnel[t][1]
							);
				}
			}else {
				deltaAngle+=4;
			}
		}
	}
	
 	private int calcXint(int r, int a) {
		return (cosTab[(a+360)%360]*r)>>SHIFT;
	}
	
	private int calcYint(int r, int a) {
		return (sinTab[a%360]*r)>>SHIFT;
	}

	@Override
	public void worker3(){
		Screen.screenClear(LunarEngine.screendataToReset,faderBackground.getCurrentColor());
	}
	
	@Override
	public void rotateBuffers() {
		rotateBuffers5();
	}

}
